<!DOCTYPE html>
<html>
<head>
    <title>Field Work 3: A Structured Arena</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            font-family: Arial, sans-serif;
        }

        #canvas {
            width: 100vw;
            height: 100vh;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
        }

        .controls label {
            display: block;
            margin: 10px 0;
        }

        .controls input {
            margin-left: 10px;
            width: 120px;
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <label>
            Wave Height:
            <input type="range" id="heightRange" min="0" max="100" value="30">
        </label>
        <label>
            Wave Speed:
            <input type="range" id="speedRange" min="0" max="100" value="50">
        </label>
        <label>
            Light Intensity:
            <input type="range" id="lightRange" min="0" max="100" value="70">
        </label>
    </div>

    <div class="info">
        <h3>Field Work 3: A Structured Arena</h3>
        <p>An interactive visualization of Timothy Drever's conceptual work featuring a wave-structured surface.</p>
        <p>• Move mouse to change perspective</p>
        <p>• Use sliders to adjust wave height, speed, and lighting</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Make canvas full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Wave parameters
        let waveHeight = 30;
        let waveSpeed = 0.5;
        let lightIntensity = 0.7;
        let time = 0;
        
        // Grid parameters
        const gridSize = 30;
        const cellSize = 20;
        
        // Mouse tracking for perspective
        let mouseX = 0;
        let mouseY = 0;
        canvas.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
            mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
        });

        // Control handlers
        document.getElementById('heightRange').addEventListener('input', (e) => {
            waveHeight = e.target.value / 2;
        });
        
        document.getElementById('speedRange').addEventListener('input', (e) => {
            waveSpeed = e.target.value / 100;
        });
        
        document.getElementById('lightRange').addEventListener('input', (e) => {
            lightIntensity = e.target.value / 100;
        });

        // Wave calculation function
        function calculateWaveHeight(x, y, time) {
            const dx = x - gridSize / 2;
            const dy = y - gridSize / 2;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            return Math.sin(distance * 0.3 + time) * waveHeight + 
                   Math.sin((x * 0.5 + y * 0.5 + time) * 0.5) * waveHeight;
        }

        // Color calculation based on height and lighting
        function calculateColor(height, maxHeight) {
            const normalizedHeight = (height + maxHeight) / (2 * maxHeight);
            const baseColor = Math.floor(normalizedHeight * 255);
            const lightFactor = lightIntensity * (0.7 + 0.3 * normalizedHeight);
            
            return `rgb(${baseColor * lightFactor},
                       ${baseColor * lightFactor},
                       ${Math.floor(baseColor * lightFactor * 1.2)})`;
        }

        // Main drawing function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Center the grid
            const offsetX = canvas.width / 2 - (gridSize * cellSize) / 2;
            const offsetY = canvas.height / 2 - (gridSize * cellSize) / 2;
            
            // Add perspective offset based on mouse position
            const perspectiveX = mouseX * 100;
            const perspectiveY = mouseY * 100;

            // Draw grid
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const height = calculateWaveHeight(x, y, time);
                    
                    // Calculate corners of the cell with perspective
                    const px1 = offsetX + x * cellSize + perspectiveX * (y / gridSize);
                    const py1 = offsetY + y * cellSize + perspectiveY * (y / gridSize) + height;
                    const px2 = px1 + cellSize;
                    const py2 = py1;
                    
                    // Draw cell
                    ctx.beginPath();
                    ctx.moveTo(px1, py1);
                    ctx.lineTo(px2, py2);
                    ctx.strokeStyle = calculateColor(height, waveHeight);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            // Update time
            time += waveSpeed * 0.05;
            
            // Continue animation
            requestAnimationFrame(draw);
        }

        // Start animation
        draw();
    </script>
</body>
</html>