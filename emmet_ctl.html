<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vector Shape Transformation Program</title>
    <style>
        body {
            font-family: monospace;
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .canvas-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        canvas {
            background: white;
            border: 1px solid #ccc;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            background: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        button {
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
        }
        
        select {
            padding: 8px;
            margin: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Vector Shape Transformation Program</h1>
        
        <div class="canvas-container">
            <canvas id="startCanvas" width="400" height="400"></canvas>
            <canvas id="transformCanvas" width="400" height="400"></canvas>
            <canvas id="endCanvas" width="400" height="400"></canvas>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>Shapes</h3>
                <button onclick="setShape('start', 'square')">Square</button>
                <button onclick="setShape('start', 'triangle')">Triangle</button>
                <button onclick="setShape('start', 'circle')">Circle</button>
                <button onclick="clearShape('start')">Clear</button>
                <br>
                <button onclick="setShape('end', 'square')">Square</button>
                <button onclick="setShape('end', 'triangle')">Triangle</button>
                <button onclick="setShape('end', 'circle')">Circle</button>
                <button onclick="clearShape('end')">Clear</button>
            </div>
            
            <div class="control-group">
                <h3>Transform Method</h3>
                <select id="transformMethod">
                    <option value="mapper">MAPPER</option>
                    <option value="ganger">GANGER</option>
                    <option value="shadow">SHADOW</option>
                </select>
                <br>
                <button onclick="startTransform()">Start Transform</button>
                <button onclick="stopTransform()">Stop</button>
            </div>
            
            <div class="control-group">
                <h3>Options</h3>
                <label>
                    Steps:
                    <input type="number" id="steps" value="60" min="10" max="200">
                </label>
                <br>
                <label>
                    Speed:
                    <input type="range" id="speed" min="1" max="100" value="50">
                </label>
            </div>
        </div>
    </div>

    <script>
        // Core classes and utilities
        class Vector {
            constructor(x, y, visible = true) {
                this.x = x;
                this.y = y;
                this.visible = visible;
            }
        }

        class Shape {
            constructor(vectors = []) {
                this.vectors = vectors;
            }

            draw(ctx, scale = 1, offsetX = 0, offsetY = 0) {
                if (this.vectors.length === 0) return;
                
                ctx.beginPath();
                ctx.moveTo(
                    this.vectors[0].x * scale + offsetX,
                    this.vectors[0].y * scale + offsetY
                );

                for (let i = 1; i < this.vectors.length; i++) {
                    const vector = this.vectors[i];
                    if (vector.visible) {
                        ctx.lineTo(
                            vector.x * scale + offsetX,
                            vector.y * scale + offsetY
                        );
                    } else {
                        ctx.moveTo(
                            vector.x * scale + offsetX,
                            vector.y * scale + offsetY
                        );
                    }
                }
                
                ctx.stroke();
            }
        }

        // Shape definitions
        const shapeDefinitions = {
            square: () => {
                const size = 100;
                const center = 200;
                return new Shape([
                    new Vector(center - size, center - size),
                    new Vector(center + size, center - size),
                    new Vector(center + size, center + size),
                    new Vector(center - size, center + size),
                    new Vector(center - size, center - size)
                ]);
            },
            
            triangle: () => {
                const size = 100;
                const center = 200;
                return new Shape([
                    new Vector(center - size, center + size),
                    new Vector(center + size, center + size),
                    new Vector(center, center - size),
                    new Vector(center - size, center + size)
                ]);
            },
            
            circle: () => {
                const vectors = [];
                const segments = 32;
                const radius = 100;
                const center = 200;
                
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    vectors.push(new Vector(
                        center + Math.cos(angle) * radius,
                        center + Math.sin(angle) * radius
                    ));
                }
                
                return new Shape(vectors);
            }
        };

        // Transform methods
        const transformMethods = {
            mapper: (start, end) => {
                const big = start.vectors.length >= end.vectors.length ? start : end;
                const small = big === start ? end : start;
                const ratio = Math.ceil(big.vectors.length / small.vectors.length);
                
                const newSmall = [];
                let smallIndex = 0;
                
                for (let i = 0; i < big.vectors.length; i++) {
                    if (smallIndex >= small.vectors.length) {
                        smallIndex = 0;
                    }
                    
                    const vector = small.vectors[smallIndex];
                    for (let j = 0; j < ratio && newSmall.length < big.vectors.length; j++) {
                        newSmall.push(new Vector(
                            vector.x + (j * (small.vectors[(smallIndex + 1) % small.vectors.length].x - vector.x)) / ratio,
                            vector.y + (j * (small.vectors[(smallIndex + 1) % small.vectors.length].y - vector.y)) / ratio,
                            vector.visible
                        ));
                    }
                    
                    smallIndex++;
                }
                
                return big === start ? [start.vectors, newSmall] : [newSmall, end.vectors];
            },
            
            ganger: (start, end) => {
                const big = start.vectors.length >= end.vectors.length ? start : end;
                const small = big === start ? end : start;
                const diff = big.vectors.length - small.vectors.length;
                
                const newSmall = [...small.vectors];
                const insertCount = Math.floor(diff / small.vectors.length);
                let remaining = diff % small.vectors.length;
                
                for (let i = 0; i < small.vectors.length && remaining > 0; i++) {
                    const insertIndex = i * (insertCount + 1) + i;
                    const vector = small.vectors[i];
                    
                    for (let j = 0; j < insertCount + 1; j++) {
                        newSmall.splice(insertIndex + j, 0, new Vector(vector.x, vector.y, vector.visible));
                    }
                    
                    remaining--;
                }
                
                return big === start ? [start.vectors, newSmall] : [newSmall, end.vectors];
            },
            
            shadow: (start, end) => {
                // Simplified SHADOW implementation
                const startLength = start.vectors.reduce((acc, v, i) => {
                    if (i === 0) return 0;
                    const prev = start.vectors[i - 1];
                    return acc + Math.sqrt(
                        Math.pow(v.x - prev.x, 2) + 
                        Math.pow(v.y - prev.y, 2)
                    );
                }, 0);
                
                const endLength = end.vectors.reduce((acc, v, i) => {
                    if (i === 0) return 0;
                    const prev = end.vectors[i - 1];
                    return acc + Math.sqrt(
                        Math.pow(v.x - prev.x, 2) + 
                        Math.pow(v.y - prev.y, 2)
                    );
                }, 0);
                
                const ratio = startLength / endLength;
                return transformMethods.mapper(start, end); // Fallback to MAPPER for now
            }
        };

        // Animation and rendering
        let startShape = null;
        let endShape = null;
        let currentFrame = 0;
        let animationId = null;

        const startCanvas = document.getElementById('startCanvas');
        const transformCanvas = document.getElementById('transformCanvas');
        const endCanvas = document.getElementById('endCanvas');
        
        const startCtx = startCanvas.getContext('2d');
        const transformCtx = transformCanvas.getContext('2d');
        const endCtx = endCanvas.getContext('2d');

        function clearCanvas(ctx) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        }

        function setShape(target, shape) {
            if (target === 'start') {
                startShape = shapeDefinitions[shape]();
                clearCanvas(startCtx);
                startShape.draw(startCtx);
            } else {
                endShape = shapeDefinitions[shape]();
                clearCanvas(endCtx);
                endShape.draw(endCtx);
            }
        }

        function clearShape(target) {
            if (target === 'start') {
                startShape = null;
                clearCanvas(startCtx);
            } else {
                endShape = null;
                clearCanvas(endCtx);
            }
        }

        function interpolateShapes(start, end, progress) {
            const vectors = [];
            for (let i = 0; i < start.length; i++) {
                vectors.push(new Vector(
                    start[i].x + (end[i].x - start[i].x) * progress,
                    start[i].y + (end[i].y - start[i].y) * progress,
                    start[i].visible
                ));
            }
            return new Shape(vectors);
        }

        function startTransform() {
            if (!startShape || !endShape) {
                alert('Please set both start and end shapes');
                return;
            }
            
            stopTransform();
            
            const method = document.getElementById('transformMethod').value;
            const steps = parseInt(document.getElementById('steps').value);
            const speed = parseInt(document.getElementById('speed').value);
            
            const [normalizedStart, normalizedEnd] = transformMethods[method](startShape, endShape);
            currentFrame = 0;
            
            function animate() {
                const progress = currentFrame / steps;
                clearCanvas(transformCtx);
                
                const interpolated = interpolateShapes(normalizedStart, normalizedEnd, progress);
                interpolated.draw(transformCtx);
                
                currentFrame++;
                
                if (currentFrame <= steps) {
                    animationId = setTimeout(() => {
                        animationId = requestAnimationFrame(animate);
                    }, 1000 / speed);
                }
            }
            
            animate();
        }

        function stopTransform() {
            if (animationId) {
                clearTimeout(animationId);
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        // Initialize with some shapes
        setShape('start', 'square');
        setShape('end', 'circle');
    </script>
</body>
</html>