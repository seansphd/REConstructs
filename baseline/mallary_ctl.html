<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRPL - Line Pattern Generator</title>
    <style>
        /* General page styling */
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        /* Control panel box */
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        input[type="number"], input[type="range"] {
            width: 200px;
            margin-right: 10px;
        }
        /* Canvas styling */
        canvas {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        /* Buttons */
        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        button:hover {
            background: #1d4ed8;
        }
        /* Canvas container */
        #canvas-container {
            position: relative;
            margin-top: 20px;
        }
        #drawingCanvas {
            border: 1px solid #ddd;
            cursor: crosshair;
        }
        #status {
            margin-top: 10px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>TRPL - Line Pattern Generator</h1>
        <div class="controls">
            <!-- Input controls for size, resolution, etc. -->
            <div class="control-group">
                <label for="height">Height (YMOD):</label>
                <input type="number" id="height" value="400" min="100" max="800">
            </div>
            <div class="control-group">
                <label for="width">Width (WIDE):</label>
                <input type="number" id="width" value="600" min="100" max="1200">
            </div>
            <div class="control-group">
                <label for="interpolations">Interpolations (XMOD):</label>
                <input type="number" id="interpolations" value="20" min="2" max="100">
            </div>
            <div class="control-group">
                <label for="resolution">Resolution (steps per inch):</label>
                <input type="number" id="resolution" value="100" min="50" max="200">
            </div>
            <div class="control-group">
                <!-- Action buttons -->
                <button id="clearBtn">Clear Canvas</button>
                <button id="generateBtn">Generate Pattern</button>
                <button id="undoBtn">Undo Last Line</button>
            </div>
            <div id="status">Draw at least two master lines by clicking and dragging on the canvas.</div>
        </div>
        <div id="canvas-container">
            <canvas id="drawingCanvas"></canvas>
        </div>
    </div>

    <script>
        class TRPL {
            constructor(canvas) {
                this.canvas = canvas;                  // Reference to the canvas
                this.ctx = canvas.getContext('2d');    // Drawing context
                this.masterLines = [];                 // Stores drawn master lines
                this.isDrawing = false;                // Track drawing state
                this.resolution = 100;                 // Default resolution
                this.currentLine = null;               // Current line being drawn
                this.setupEventListeners();            // Bind mouse events
                this.updateStatus();                   // Update text status
            }

            setupEventListeners() {
                // Mouse events for drawing
                this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.stopDrawing());
                this.canvas.addEventListener('mouseout', () => this.stopDrawing());
            }

            getMousePos(e) {
                // Get mouse position relative to canvas
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            startDrawing(e) {
                this.isDrawing = true;
                const pos = this.getMousePos(e);
                this.currentLine = [pos];
                
                // Start new path for user feedback
                this.ctx.beginPath();
                this.ctx.strokeStyle = '#000';
                this.ctx.lineWidth = 2;
                this.ctx.moveTo(pos.x, pos.y);
            }

            draw(e) {
                if (!this.isDrawing) return;
                
                const pos = this.getMousePos(e);
                const lastPoint = this.currentLine[this.currentLine.length - 1];
                
                // Add new point
                this.currentLine.push(pos);
                
                // Draw live feedback line
                this.ctx.lineTo(pos.x, pos.y);
                this.ctx.stroke();
            }

            stopDrawing() {
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                if (this.currentLine && this.currentLine.length > 1) {
                    // Save line after drawing
                    this.masterLines.push(this.currentLine);
                    this.updateStatus();
                }
            }

            updateStatus() {
                // Update instruction/status text
                const status = document.getElementById('status');
                if (this.masterLines.length === 0) {
                    status.textContent = 'Draw at least two master lines by clicking and dragging on the canvas.';
                } else if (this.masterLines.length === 1) {
                    status.textContent = 'Draw one more master line to generate a pattern.';
                } else {
                    status.textContent = `${this.masterLines.length} master lines drawn. Click "Generate Pattern" to create interpolations.`;
                }
            }

            generatePattern() {
                if (this.masterLines.length < 2) {
                    alert('Please draw at least two master lines first');
                    return;
                }

                const steps = parseInt(document.getElementById('interpolations').value);
                
                // Save current master lines
                const masterLinesCopy = [...this.masterLines];
                
                // Clear canvas
                this.clear(false);
                
                // Redraw master lines in black
                this.ctx.strokeStyle = '#000';
                this.ctx.lineWidth = 2;
                masterLinesCopy.forEach(line => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(line[0].x, line[0].y);
                    line.forEach(point => {
                        this.ctx.lineTo(point.x, point.y);
                    });
                    this.ctx.stroke();
                });

                // Interpolated lines in grey
                this.ctx.strokeStyle = '#666';
                this.ctx.lineWidth = 1;
                
                for (let i = 0; i < masterLinesCopy.length - 1; i++) {
                    const line1 = masterLinesCopy[i];
                    const line2 = masterLinesCopy[i + 1];
                    
                    for (let step = 1; step < steps; step++) {
                        const t = step / steps;
                        const interpolatedLine = [];
                        
                        // Use shortest line length to avoid mismatch
                        const pointCount = Math.min(line1.length, line2.length);
                        
                        for (let j = 0; j < pointCount; j++) {
                            interpolatedLine.push({
                                x: line1[j].x + (line2[j].x - line1[j].x) * t,
                                y: line1[j].y + (line2[j].y - line1[j].y) * t
                            });
                        }
                        
                        // Draw interpolated line
                        this.ctx.beginPath();
                        this.ctx.moveTo(interpolatedLine[0].x, interpolatedLine[0].y);
                        interpolatedLine.forEach(point => {
                            this.ctx.lineTo(point.x, point.y);
                        });
                        this.ctx.stroke();
                    }
                }
                
                // Restore master lines array
                this.masterLines = masterLinesCopy;
            }

            clear(resetMasterLines = true) {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                if (resetMasterLines) {
                    this.masterLines = [];
                    this.updateStatus();
                }
            }

            undoLastLine() {
                // Remove last line
                if (this.masterLines.length > 0) {
                    this.masterLines.pop();
                    this.clear(false);
                    
                    // Redraw remaining lines
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 2;
                    this.masterLines.forEach(line => {
                        this.ctx.beginPath();
                        this.ctx.moveTo(line[0].x, line[0].y);
                        line.forEach(point => {
                            this.ctx.lineTo(point.x, point.y);
                        });
                        this.ctx.stroke();
                    });
                    
                    this.updateStatus();
                }
            }

            setResolution(value) {
                this.resolution = value;
            }
        }

        // Initialise the application
        const canvas = document.getElementById('drawingCanvas');
        canvas.width = 600;
        canvas.height = 400;
        
        const trpl = new TRPL(canvas);

        // Button event listeners
        document.getElementById('generateBtn').addEventListener('click', () => {
            trpl.generatePattern();
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            trpl.clear();
        });

        document.getElementById('undoBtn').addEventListener('click', () => {
            trpl.undoLastLine();
        });

        document.getElementById('resolution').addEventListener('change', (e) => {
            trpl.setResolution(parseInt(e.target.value));
        });

        // Update canvas size on input change
        document.getElementById('width').addEventListener('change', (e) => {
            canvas.width = parseInt(e.target.value);
            trpl.clear();
        });

        document.getElementById('height').addEventListener('change', (e) => {
            canvas.height = parseInt(e.target.value);
            trpl.clear();
        });
    </script>
</body>
</html>
