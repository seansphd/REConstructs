
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vector Transformation Program</title>
    <style>
        /* General page styling */
        body {
            font-family: Arial, sans-serif; /* Use a simple font */
            max-width: 1200px;              /* Keep content centred with max width */
            margin: 0 auto;                 /* Centre page */
            padding: 20px;
            background: #f0f0f0;            /* Light grey background */
        }

        /* Container for all content */
        .container {
            display: flex;
            flex-direction: column;         /* Stack items vertically */
            align-items: center;
            gap: 20px;                      /* Space between sections */
        }

        /* Holds the two canvases side by side */
        .canvas-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Canvas styling */
        canvas {
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Small shadow */
        }

        /* Box for the controls */
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 600px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        /* Button styling */
        button {
            padding: 8px 16px;
            margin: 5px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #0056b3; /* Darker blue when hovered */
        }

        select {
            padding: 8px;
            margin: 5px;
        }

        /* Status text */
        .status {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Vector Transformation Program</h1>

        <!-- Two canvases: source shape and result shape -->
        <div class="canvas-container">
            <canvas id="sourceCanvas" width="400" height="400"></canvas>
            <canvas id="resultCanvas" width="400" height="400"></canvas>
        </div>

        <!-- Controls for user interaction -->
        <div class="controls">
            <div class="control-group">
                <button id="clearSource">Clear Source</button>
                <button id="clearTarget">Clear Target</button>
                <button id="undo">Undo Last Point</button>
            </div>

            <div class="control-group">
                <label>Transformation Method:</label>
                <select id="method">
                    <option value="mapper">Mapper</option>
                    <option value="ganger">Ganger</option>
                    <option value="shadow">Shadow</option>
                </select>
            </div>

            <div class="control-group">
                <label>Number of Intermediate Frames:</label>
                <input type="range" id="frames" min="1" max="50" value="20">
                <span id="frameCount">20</span>
            </div>

            <div class="control-group">
                <button id="transform">Transform</button>
                <button id="animate">Animate</button>
                <button id="stop">Stop</button>
            </div>

            <div class="status" id="status">
                Draw shapes on both canvases, then click Transform
            </div>
        </div>
    </div>

    <script>
        /* Represents a 2D point */
        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            /* Linear interpolation between two points */
            static interpolate(v1, v2, t) {
                return new Vector(
                    v1.x + (v2.x - v1.x) * t,
                    v1.y + (v2.y - v1.y) * t
                );
            }
        }

        /* A shape is a set of points and connecting lines */
        class Shape {
            constructor() {
                this.points = [];  // List of Vector objects
                this.vectors = []; // List of line segments
            }

            /* Add a new point */
            addPoint(x, y) {
                this.points.push(new Vector(x, y));
                this.updateVectors();
            }

            /* Update line segments between points */
            updateVectors() {
                if (this.points.length < 2) return;

                this.vectors = [];
                for (let i = 1; i < this.points.length; i++) {
                    this.vectors.push({
                        start: this.points[i-1],
                        end: this.points[i]
                    });
                }
            }

            /* Draw the shape on canvas */
            draw(ctx) {
                if (this.points.length === 0) return;

                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);

                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }

                ctx.stroke();

                // Draw each point (green for first, red for others)
                this.points.forEach((point, index) => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = index === 0 ? 'green' : 'red';
                    ctx.fill();
                });
            }
        }

        /* Main program logic */
        class TransformationProgram {
            constructor() {
                this.sourceShape = new Shape();   // Shape on left canvas
                this.targetShape = new Shape();   // Shape on right canvas
                this.currentFrame = 0;
                this.frames = [];                 // List of interpolated shapes
                this.animationId = null;          // For animation loop

                this.setupCanvases();
                this.setupControls();
            }

            /* Setup canvas click events */
            setupCanvases() {
                this.sourceCanvas = document.getElementById('sourceCanvas');
                this.resultCanvas = document.getElementById('resultCanvas');
                this.sourceCtx = this.sourceCanvas.getContext('2d');
                this.resultCtx = this.resultCanvas.getContext('2d');

                const addPoint = (canvas, event) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;

                    if (canvas === this.sourceCanvas) {
                        this.sourceShape.addPoint(x, y);
                        this.redrawCanvas(this.sourceCtx, this.sourceShape);
                    } else {
                        this.targetShape.addPoint(x, y);
                        this.redrawCanvas(this.resultCtx, this.targetShape);
                    }
                };

                [this.sourceCanvas, this.resultCanvas].forEach(canvas => {
                    canvas.addEventListener('click', (e) => addPoint(canvas, e));
                });
            }

            /* Setup button and slider controls */
            setupControls() {
                document.getElementById('clearSource').onclick = () => {
                    this.sourceShape = new Shape();
                    this.redrawCanvas(this.sourceCtx, this.sourceShape);
                };

                document.getElementById('clearTarget').onclick = () => {
                    this.targetShape = new Shape();
                    this.redrawCanvas(this.resultCtx, this.targetShape);
                };

                document.getElementById('transform').onclick = () => this.transform();
                document.getElementById('animate').onclick = () => this.startAnimation();
                document.getElementById('stop').onclick = () => this.stopAnimation();

                document.getElementById('frames').oninput = (e) => {
                    document.getElementById('frameCount').textContent = e.target.value;
                };

                document.getElementById('undo').onclick = () => {
                    if (this.sourceShape.points.length > 0) {
                        this.sourceShape.points.pop();
                        this.sourceShape.updateVectors();
                        this.redrawCanvas(this.sourceCtx, this.sourceShape);
                    }
                };
            }

            /* Clear and redraw shape */
            redrawCanvas(ctx, shape) {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                shape.draw(ctx);
            }

            /* Generate interpolated frames */
            transform() {
                const method = document.getElementById('method').value;
                const frameCount = parseInt(document.getElementById('frames').value);

                if (this.sourceShape.points.length < 2 || this.targetShape.points.length < 2) {
                    document.getElementById('status').textContent = 'Both shapes need at least 2 points';
                    return;
                }

                this.frames = [];

                for (let i = 0; i <= frameCount; i++) {
                    const t = i / frameCount;
                    const frame = new Shape();

                    const sourcePoints = this.sourceShape.points;
                    const targetPoints = this.targetShape.points;

                    let interpolatedPoints;
                    switch(method) {
                        case 'mapper':
                            interpolatedPoints = this.mapperMethod(sourcePoints, targetPoints, t);
                            break;
                        case 'ganger':
                            interpolatedPoints = this.gangerMethod(sourcePoints, targetPoints, t);
                            break;
                        case 'shadow':
                            interpolatedPoints = this.shadowMethod(sourcePoints, targetPoints, t);
                            break;
                    }

                    frame.points = interpolatedPoints;
                    frame.updateVectors();
                    this.frames.push(frame);
                }

                this.currentFrame = 0;
                this.drawFrame(this.currentFrame);
            }

            /* Mapper method: pairs up points by index */
            mapperMethod(sourcePoints, targetPoints, t) {
                const maxPoints = Math.max(sourcePoints.length, targetPoints.length);
                const points = [];

                for (let i = 0; i < maxPoints; i++) {
                    const sourcePoint = sourcePoints[Math.min(i, sourcePoints.length - 1)];
                    const targetPoint = targetPoints[Math.min(i, targetPoints.length - 1)];
                    points.push(Vector.interpolate(sourcePoint, targetPoint, t));
                }

                return points;
            }

            /* Ganger method: uses last available point if lists differ in length */
            gangerMethod(sourcePoints, targetPoints, t) {
                const maxPoints = Math.max(sourcePoints.length, targetPoints.length);
                const points = [];

                for (let i = 0; i < maxPoints; i++) {
                    let sourcePoint = sourcePoints[i] || sourcePoints[sourcePoints.length - 1];
                    let targetPoint = targetPoints[i] || targetPoints[targetPoints.length - 1];
                    points.push(Vector.interpolate(sourcePoint, targetPoint, t));
                }

                return points;
            }

            /* Shadow method: interpolates along length of shapes */
            shadowMethod(sourcePoints, targetPoints, t) {
                const points = [];
                const sourceLength = this.getShapeLength(sourcePoints);
                const targetLength = this.getShapeLength(targetPoints);
                const numPoints = Math.max(sourcePoints.length, targetPoints.length);

                for (let i = 0; i < numPoints; i++) {
                    const sourceT = i / (sourcePoints.length - 1);
                    const targetT = i / (targetPoints.length - 1);

                    const sourcePoint = this.getPointAtLength(sourcePoints, sourceT * sourceLength);
                    const targetPoint = this.getPointAtLength(targetPoints, targetT * targetLength);

                    points.push(Vector.interpolate(sourcePoint, targetPoint, t));
                }

                return points;
            }

            /* Calculate total shape length */
            getShapeLength(points) {
                let length = 0;
                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].x - points[i-1].x;
                    const dy = points[i].y - points[i-1].y;
                    length += Math.sqrt(dx * dx + dy * dy);
                }
                return length;
            }

            /* Find point at specific length along shape */
            getPointAtLength(points, targetLength) {
                let currentLength = 0;

                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].x - points[i-1].x;
                    const dy = points[i].y - points[i-1].y;
                    const segmentLength = Math.sqrt(dx * dx + dy * dy);

                    if (currentLength + segmentLength >= targetLength) {
                        const remainingLength = targetLength - currentLength;
                        const t = remainingLength / segmentLength;
                        return Vector.interpolate(points[i-1], points[i], t);
                    }

                    currentLength += segmentLength;
                }

                return points[points.length - 1];
            }

            /* Draw a single frame */
            drawFrame(frameIndex) {
                if (!this.frames[frameIndex]) return;
                this.redrawCanvas(this.resultCtx, this.frames[frameIndex]);
            }

            /* Start animation */
            startAnimation() {
                if (this.frames.length === 0) {
                    this.transform();
                }

                this.stopAnimation();

                const frameRate = 10; // frames per second
                const interval = 1000 / frameRate;

                const animate = () => {
                    this.currentFrame = (this.currentFrame + 1) % this.frames.length;
                    this.drawFrame(this.currentFrame);
                    this.animationId = setTimeout(animate, interval);
                };

                this.animationId = setTimeout(animate, interval);
            }

            /* Stop animation */
            stopAnimation() {
                if (this.animationId !== null) {
                    clearTimeout(this.animationId);
                    this.animationId = null;
                }
            }
        }

        /* Start program when page loads */
        window.onload = () => {
            new TransformationProgram();
        };
    </script>
</body>
</html>


